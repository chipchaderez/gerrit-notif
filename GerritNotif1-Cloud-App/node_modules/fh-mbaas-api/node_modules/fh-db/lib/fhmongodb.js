var mongodb = require('mongodb');
var Db = mongodb.Db;
var Connection = mongodb.Connection;
var Server = mongodb.Server;
var ReplSetServers = mongodb.ReplSetServers;
var BSONNative = mongodb.BSONNative;
var BSONPure = mongodb.BSONPure;
var sys = require('sys');
var util = require("util");
var EventEmitter = require('events').EventEmitter;
var exec = require('child_process').exec;

var Database = function (host, port, pDriverOptions, retryWaitTime) {
  EventEmitter.call(this);
  this.queue = [];
  this.replicaSetServers = null;
  this.name = null;
  this.db = null;
  this.ready = false;
  this.driver_options = { w: 1, j: true, numberOfRetries: 5, retryMiliSeconds: 2000, native_parser:false};
  if (pDriverOptions) {
    for (var field in pDriverOptions) {
      this.driver_options[field] = pDriverOptions[field];
    }
  }
  this.hostname = (host) ? host : "localhost";
  this.base_port = (port) ? port : 27017;
  var servers = new Array();

  this.retryInternval = 1000;
  this.retryTimes = 30;
  if (retryWaitTime) {
    this.retryInternval = retryWaitTime.interval;
    this.retryTimes = retryWaitTime.limit;
  }

  if (Array.isArray(this.hostname)) {
    if (Array.isArray(this.base_port)) {
      for (var i = 0; i < this.hostname.length; i++) {
        servers[i] = new Server(this.hostname[i], this.base_port[i], {});
      }
    }
    else {
      for (var i = 0; i < this.hostname.length; i++) {
        servers[i] = new Server(this.hostname[i], this.base_port, {});
      }
    }

    this.replicaSetServers = new ReplSetServers(servers);
  } else {
    this.replicaSetServers = new Server(this.hostname, this.base_port, {}); // ReplSetServers(servers);
  }
};

sys.inherits(Database, EventEmitter);

Database.prototype.createObjectIdFromHexString = function (str) {
  var ret;
  if (this.driver_options.native_parser) {
    ret = BSONNative.ObjectID.createFromHexString(str);
  }
  else {
    ret = BSONPure.ObjectID.createFromHexString(str);
  }
  return ret;
};

Database.prototype.tearUp = function (auth) {
  var self = this;
  var retryCount = 0;
  var interval = null;

  function connectToDb() {
    if (retryCount < self.retryTimes) {
      self.db.open(function (err, db) {
        if (null != err) {
          retryCount++;
          console.warn("Failed to connect to db: " + err + " . Attempt: " + retryCount);
        } else {
          retryCount = 0;
          if (interval) {
            clearInterval(interval);
          }
          authenticateUser(auth);
        }
      });
    } else {
      if (!self.ready) {
        self.emit('dbconnectionerror', "Can not connect to MongoDB after " + self.retryTimes + " attempts.");
      }
    }
  }

  if (undefined == this.db || null == this.db) {
    this.db = new Db(this.name, this.replicaSetServers, this.driver_options);
    self.db.open(function (err, db) {
      if (null != err) {
        interval = setInterval(connectToDb, self.retryInternval);
      } else {
        authenticateUser(auth);
      }
    });
    this.db.on('error', function (err) {
      console.warn("mongodb emits error: " + err);
      self.emit('error', err);
    });
  }

  function notifyUp() {
    console.info("Database connection established");
    self.ready = true;
    self.emit('tearUp');
  }

  function authenticateUser(auth) {
    if (auth && auth.user && auth.pass) {
      console.info("Authenticate user...");
      self.db.authenticate(auth.user, auth.pass, function (err, result) {
        if (err) return self.emit('dbconnectionerror', err);
        notifyUp();
      });
    } else {
      notifyUp();
    }
  }

};

Database.prototype.tearDown = function () {
  if (null !== this.db) {
    var olddb = this.db;
    this.db = null;
    this.ready = false;
    olddb.close();
  }

  this.emit('tearDown');
};

Database.prototype.create = function (collectionName, data, callback) {
  if (null === this.db) return callback(new Error("no database open"), null);
  var self = this;
  self.db.collection(collectionName, function (err, collection) {
    if (err) return callback(err, null);
    if (null === collection) return callback(new Error("Collection doesn't exist"), null);
    // if we're being supplied GUID _ids make them into objectIDs
    if (data instanceof Array){
      data.forEach(function(doc){
        if (doc.hasOwnProperty('_id') && doc._id.length === 24){
          try{
             doc._id= self.createObjectIdFromHexString(doc._id);
          }catch(err){
            // We can step over these - it'll still get created OK
          }
        }
      });
    }
    collection.insert(data, function (err, objects) {
      if (err) return callback(err, null);
      self.db.lastError(function (errs, errorObjects) {
        if (errs) return callback(errs, null);
        if (errorObjects) {
          for (var j = 0; j < errorObjects.length; j++) {
            var e = errorObjects[j];
            if (e.err != null) return callback(new Error(JSON.stringify(errorObjects)), null);
          }
        }
        return callback(err, objects);
      });
    });
  });
};

Database.prototype.find = function (collectionName, query, callback) {
  return this.findWithSelection(collectionName, query, {}, {}, callback);
};

Database.prototype.findWithSelectionCursor = function (collectionName, query, selection, options, callback) {
  if (null === this.db) return callback(new Error("no database open"), null);

  this.db.collection(collectionName, function (err, collection) {
    if (null !== err) return callback(err, null);

    collection.find(query, selection, options, callback);
  });
};

Database.prototype.findWithSelection = function (collectionName, query, selection, options, callback) {
  this.findWithSelectionCursor(collectionName, query, selection, options, function (err, cursor) {
    if (null !== err) return callback(err, null);

    cursor.toArray(function (err, items) {
      return callback(err, items);
    });
  });
};

Database.prototype.group = function (collectionName, query, callback) {
  if (null === this.db) return callback(new Error("no database open"), null);

  this.db.collection(collectionName, function (err, collection) {
    if (null !== err) return callback(err, null);

    //keys, condition, initial, reduce, command, callback
    collection.group(query.keys, query.cond, query.initial, query.reduce, true, function (err, results) {
      if (null !== err) return callback(err, null);
      return callback(err, results);
    });
  });
};

Database.prototype.distinct = function (collectionName, key, query, callback) {
  if (null === this.db) {
    return callback(new Error("no database open"), null);
  }
  this.db.collection(collectionName, function (err, collection) {
    if (null !== err) {
      return callback(err, null);
    }
    collection.distinct(key, query, callback);
  });
};

Database.prototype.update = function (collectionName, criteria, data, upsert, callback) {
  if (null === this.db) return callback(new Error("no database open"), null);

  this.db.collection(collectionName, function (err, collection) {
    if (null !== err) return callback(err, null);
    collection.update(criteria, data, {
      upsert: 1
    }, function (err, docs) {
      callback(err, docs);
    });
  });
};

Database.prototype.remove = function (collectionName, id, callback) {
  if (null === this.db) return callback(new Error("no database open"), null);

  var self = this;

  this.db.collection(collectionName, function (err, collection) {
    if (null !== err) return callback(err, null);

    collection.remove({
      _id: self.createObjectIdFromHexString(id)
    }, function (err, docs) {
      return callback(err, docs);
    });
  });
};

Database.prototype.removeAll = function (collectionName, callback) {
  if (null === this.db) return callback(new Error("no database open"), null);

  this.db.collection(collectionName, function (err, collection) {
    if (null !== err) return callback(err, null);

    collection.find({}, function (err, cursor) {
      if (null !== err) return callback(err, null);

      collection.remove({}, {safe: true}, function (err, numDeleted) {  // need safe mode to get number of docs deleted
        callback(err, numDeleted);
      });
    });
  });
};

Database.prototype.collectionExists = function (collectionName, callback) {
  if (null === this.db) return callback(new Error("no database open"), null);

  this.db.collectionNames(collectionName, function (err, collections) {
    if (err) return callback(err, null);
    if (collections.length == 0) return callback(null, false);
    else return callback(null, true);
  });
};

Database.prototype.createCollectionWithIndex = function (collectionName, index, callback) {
  if (null === this.db) return callback(new Error("no database open"), null);

  this.db.createCollection(collectionName, function (err, collection) {
    if (err) {
      console.log("Error from createCollection(): " + JSON.stringify(err));
      return callback(err);
    }
    collection.ensureIndex([
      [index, 1]
    ], true, function (err, indexName) {
      callback(err);
    });
  });
};

Database.prototype.createCollectionWithOptions = function (collectionName, options, callback) {
  if (null === this.db) return callback(new Error("no database open"), null);

  this.db.createCollection(collectionName, options, function (err, collection) {
    if (err) {
      console.log("Error from createCollection(): " + JSON.stringify(err));
    }
    return callback(err);
  });
};

Database.prototype.findOne = function (collectionName, selector, fields, callback) {
  if (null === this.db) return callback(new Error("no database open"), null);

  this.db.collection(collectionName, function (err, collection) {
    if (err) return callback(err, null);
    collection.findOne(selector, fields, callback);
  });
};

Database.prototype.countCollection = function (collectionName, callback) {
  if (null === this.db) return callback(new Error("no database open"), null);

  this.db.collection(collectionName, function (err, collection) {
    if (err) return callback(err, null);
    collection.count(callback);
  });
};

Database.prototype.collectionNames = function (callback) {
  if (null === this.db) return callback(new Error("no database open"), null);
  this.db.collectionNames(callback);
};

Database.prototype.collectionInfo = function (collectionName, callback) {
  if (null === this.db) {
    return callback(new Error("no database open"), null);
  }
  var coll = this.db.collection(collectionName);
  if (!coll) {
    return callback(new Error("No collection found with name " + collectionName), null);
  }
  return coll.stats(callback);
};

Database.prototype.dropDatabase = function (callback) {
  if (null === this.db) return callback(new Error("no database open"), null);
  this.db.dropDatabase(callback);
};

/**
 * Add an index to  field/fields
 * @param indexes : it could be single index or mixed indexes. {"name":1} | {"name.firstname":-1} | {"location":"2d"} |{"location":"2d","name":1}
 *
 */
Database.prototype.index = function (collectionName, indexes, callback) {
  if (null === this.db) return callback(new Error("no database open"), null);
  this.db.collection(collectionName, function (err, collection) {
    if (null === collection) return callback(new Error("Collection doesn't exist"), null);
    if (err) {
      return callback(err);
    }
    collection.ensureIndex(indexes, function (err, indexName) {
      callback(err, indexName);
    });
  });
};

Database.prototype.checkStatus = function (cb) {
  if (null == this.db) return cb(new Error("no database open"));
  this.db.collections(function (err, result) {
    if (err) return cb(err);
    return cb();
  });
};

Database.prototype.collection = function (name, cb) {
  if (null == this.db) return cb(new Error("no database open"));
  this.db.collection(name, cb);
};

exports.Database = Database;
