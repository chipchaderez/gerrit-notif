var request = require('request');
var async = require('async');
var fs = require('fs');
var crypto = require('crypto');
var backUpFileStream;
var recoveryFileStream;

exports.Reporting = Reporting;

function Reporting(config, lgr) {
  validateConfig(config);
  this.config = config;
  if (lgr) {
    this.lgr = lgr;
  } else {
    this.lgr = {info: function(){}, debug: function(){}, error: function(){}};
  }
  this.msgNumPrefix = crypto.createHash('md5').update(Math.random().toString()).digest('hex');
  this.msgNumCounter = 0;
}

Reporting.prototype.msgNum = function () {
  return "" + this.msgNumPrefix + "_" + (this.msgNumCounter++);
};

Reporting.prototype.logMessage = function (topic, msg, cb) {
  msg._ts = new Date().getTime();
  msg._mn = this.msgNum();
  msg._ho = this.config.host;
  msg._cl = this.config.cluster;
  var self = this;
  async.parallel([
    function (callback) {
      self.logMessageToHTTP(topic, msg, callback);
    },
    function (callback) {
      self.logMessageToFile(topic, msg, callback);
    }
  ], function (err, results) {
    if (cb) {
      return cb(err, results);
    }
  });
};

Reporting.prototype.logMessageToHTTP = function (topic, msg, cb) {
  var self = this;

  // bugfix 3102: only do realtime sending if config to do so is set
  if(this.config && this.config.realTimeLoggingEnabled !== true) return cb();

  if (this.config && this.config.msgServer && this.config.msgServer.logMessageURL) {
    var apiToCall = this.config.msgServer.logMessageURL.replace(/TOPIC/g, topic);
    this.lgr.debug("logMessageToHTTP(): Calling API URL " + apiToCall);
    request({
      uri: apiToCall,
      method: 'POST',
      json: msg
    }, function (error, response, body) {
      if (!error && response && response.statusCode === 200) {
        self.lgr.debug("Successfully logged message: " + body); // Print the response
      } else {
        self.lgr.error("Error logging message, error: " + JSON.stringify(error) + ", statusCode: " + ((response)?response.statusCode:"no response") + ", body: " + body);
        if (self.config && self.config.recoveryFiles && self.config.recoveryFiles.fileName) {
          var fileName = self.config.recoveryFiles.fileName.replace(/TOPIC/g, topic);
          self.saveToFile(fileName, formatMessageForFile(msg, topic), function () {});
        } else {
          self.lgr.info('Not saving to recovery file, since no recoveryFiles config');
        }
      }
      return cb(error, {handler: "logMessageToHTTP", result: {status: "ok", reason: "success", info: {response: response, body: body}}});
    });
  } else {
    self.lgr.info('Not sending to message server, since no msgServer config');
    return cb(null, {handler:  "logMessageToHTTP", result: {status: "fail", reason: "no config", info: {}}});
  }
};

function formatMessageForFile(msg, topic) {
  return {"MD5": reportingutils.MD5(JSON.stringify(msg)), "message": msg, "topic": topic};
}

Reporting.prototype.logMessageToFile = function (topic, msg, cb) {
  if (this.config && this.config.backupFiles && this.config.backupFiles.fileName) {
    var fileName = this.config.backupFiles.fileName.replace(/TOPIC/g, topic);
    this.lgr.debug("logMessageToFile(): fileName: " + fileName);
    this.saveToFile(fileName, formatMessageForFile(msg, topic), function (err) {
      if (!err) {
        return cb(null, {handler:  "logMessageToFile", result: {status: "ok", reason: "success", info: {}}});
      }
    });
  } else {
    this.lgr.info('Not saving to backup file, since no backupFiles config');
    return cb(null, {handler:  "logMessageToFile", result: {status: "fail", reason: "no config", info: {}}});
  }
};

//note backUpFileStream and recoveryFileStream are singletons and are only created once per application lifecycle.
//this is to address the problem of having too many file handles open ticket
Reporting.prototype.saveToFile = function (filepath, msg, cb) {
  var stream;
  var fileFlags = {flags:'a'};
  if(this.config.backupFiles && filepath === this.config.backupFiles.fileName){
    if(! backUpFileStream){
      backUpFileStream = fs.createWriteStream(filepath,fileFlags);
    }
    stream = backUpFileStream;
  }else if (this.config.recoveryFiles && filepath === this.config.recoveryFiles.fileName){
    if(! recoveryFileStream){
      recoveryFileStream = fs.createWriteStream(filepath,fileFlags);
    }
    stream = recoveryFileStream;
  }else if(filepath){
    //fallback to creating a write stream and destroying it?
    var tempStream = fs.createWriteStream(filepath , fileFlags);
    tempStream.write(JSON.stringify(msg) + "\n");
    tempStream.destroySoon();
  }
  if(stream){
    stream.write(JSON.stringify(msg) + "\n");    
  }

  if (cb) return cb();
};

function validateConfig(config) {
  if (!config) {
    throw new Error("Invalid config");
  }
  if (!config.host) {
    throw new Error("Invalid config: no host");
  }
  if (!config.cluster) {
    throw new Error("Invalid config: no cluster");
  }
}

var reportingutils = {
  generateID: function (message) {
    return reportingutils.MD5(JSON.stringify(message)) + "_" + reportingutils.getDatePart(message);
  },
  
  prefixZeroIfReq: function (val) {
    val = val.toString();
    return val.length > 1 ? val : '0' + val;
  },
  
  parseMonth: function (month) {
    return reportingutils.prefixZeroIfReq(month + 1);
  },
  
  parseDate: function (date) {
    return reportingutils.prefixZeroIfReq(date);
  },
  
  toYYYYMMDD: function (ts) {
    var tsDate = new Date(ts);
    var ret = tsDate.getFullYear() + reportingutils.parseMonth(tsDate.getMonth()) + reportingutils.parseDate(tsDate.getDate());
    return ret;
  },
  
  getDefaultDateForMessage: function () {
    return 0;
  },
  
  getDatePart: function(msg) {
    var ts = (msg._ts)?msg._ts:reportingutils.getDefaultDateForMessage();
    return reportingutils.toYYYYMMDD(ts);
  },
  
  MD5: function(str) {
    return crypto.createHash('md5').update(str).digest('hex');
  }
};

exports.reportingutils = reportingutils;

