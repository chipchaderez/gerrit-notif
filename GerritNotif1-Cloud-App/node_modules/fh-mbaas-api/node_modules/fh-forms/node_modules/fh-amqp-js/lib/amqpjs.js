var amqp = require('amqp');
var util = require("util");
var async = require("async");
var events = require('events');
var url = require('url');
var _ = require('lodash');
var parseClusterNodes = require("./parseClusterNodes");

function debug(){
  if(process.env && process.env.NODE_DEBUG){
    console.log.apply(null, arguments);
  }
}

/**
 * FH AMQP manager to handle RabbitMQ connections.
 * @param {Object} cfg Specify the AMQP connection details and other connection options.
 *        {Object} cfg.clusterNodes Required. The clusterNodes can be either an array of amqp URIs, or the connection configuration object specified in https://github.com/postwait/node-amqp#connection-options-and-url
 *                                  If the clusterNodes are an array of amqp URIs, they will be converted to node-amqp connection configuration.
 *                 cfg.options Other connection options can be passed down to node-amqp. E.g. Auto reconnect options.
 */
function AMQPManager(cfg) {
  var _connection;
  var self = this;
  var defaultOptions = {
    reconnect: true,
    reconnectBackoffStrategy: 'linear',
    reconnectBackoffTime: 5000,
    cachePublish: false,
    maxCachePublishSize: 1000
  };
  var defaultConnectOptions = {
    hostPreference: 0,
    connectionTimeout: 5000
  };
  var _pendingSubscribers = [];
  var _cachedPublishMessages = [];
  var _options;
  var _connectionCfg;

  // validate config
  if (!cfg.clusterNodes) throw new Error("'clusterNodes' config param missing");

  // 'clusterNodes' should be an array, but can be a string if passed from commandline
  if (typeof cfg.clusterNodes === 'string') {
    try{
      cfg.clusterNodes = JSON.parse(cfg.clusterNodes);
    }catch(e){
      //could be just a single url
    }
  }

  /** Public methods */

  /**
   * Connect to our Message Bus Cluster. 
   */
  this.connectToCluster = function() {
    var clusterNodes = cfg.clusterNodes;
    if(_.isString(clusterNodes)){
      clusterNodes = [clusterNodes];
    }
    if(_.isArray(clusterNodes)){
      _connectionCfg = parseClusterNodes(clusterNodes);
    } else {
      _connectionCfg = clusterNodes;
    }
    _connectionCfg = _.extend({}, defaultConnectOptions, _connectionCfg);
    _options = _.extend({}, defaultOptions, cfg.options || {});

    setupConn(_connectionCfg, _options);
  };

  /**
   * Return the actual node-amqp connection object
   * @param  {Function} cb The callback function
   */
  this.getConnection = function(cb){
    if(_connection && !_connection._isClosed){
      return cb(null, _connection);
    } else {
      var timer;
      var callback = function(){
        clearTimeout(timer);
        return cb(null, _connection);
      };
      timer = setTimeout(function(){
        if(!_connection || _connection._isClosed){
          debug('no connection established in ' + _connectionCfg.connectionTimeout + 'ms');
          self.removeListener('ready', callback);
          return cb('failed to connect to message bus');
        }
      }, _connectionCfg.connectionTimeout);
      self.once('ready', callback);
    }
  };

  /**
   * Quickly check if there is an active RabbitMQ connection.
   * @param  {Function} cb The callback function. Error will be returned if there is no active connection.
   */
  this.ping = function(cb){
    this.getConnection(cb);
  };

  /**
   * Return an exchange with give name and options
   * @param  {String}   name  The exchange name
   * @param  {Object}   opts  Exchange options. e.g. type, durable, confirm, autodelete. 
   *                          If not specified, the default will be: {type:'topic', durable: true, confirm: true, autoDelete: false}
   * @param  {Function} cb    The callback function
   */
  this.getExchange = function(name, opts, cb){
    var callback = cb;
    if(!callback && _.isFunction(opts)){
      callback = opts;
      opts = null;
    }
    if(!callback){
      throw new Error('No callback function specified');
    }
    var options = opts || {
      type:'topic',
      durable: true,
      confirm: true,
      autoDelete: false
    };
    if(!options.type){
      return callback(new Error('no exchange type specified in the opts'));
    }
    this.getConnection(function(err, connection){
      if(err){
        return callback(err);
      }
      connection.exchange(name, options, function(ex){
        return callback(undefined, ex);
      });
    });
  };

  /**
   * Publish to the named topic exchange
   * @param  {String}   exchangeName The exchange name
   * @param  {String}   topic        The topic name
   * @param  {String}   message      The message
   * @param  {Object}   opts         The option for the message
   * @param  {Function} cb           The callback
   */
  this.publishTopic = function(exchangeName, topic, message, opts, cb){
    var callback = cb;
    if(!callback && _.isFunction(opts)){
      callback = opts;
      opts = null;
    }
    if(!callback){
      callback = function(){};
    }
    var options = opts || {
      contentType: 'application/json',
      deliveryMode: 2
    };
    this.getExchange(exchangeName, function(err, exchange){
      if(err){
        if(_options.cachePublish){
          var publishMsg = {
            exchange: exchangeName,
            topic: topic,
            message: message,
            options: options
          };
          _cachedPublishMessages.push(publishMsg);
          if(_cachedPublishMessages.length > _options.maxCachePublishSize){
            _cachedPublishMessages.shift();
          }
          return callback();
        } else {
          return callback(err);
        }
      }
      exchange.publish(topic, message, options, function(ack){
        // Note: oddly, ack will be false if the message succeeds
        if (ack !== false) return callback("Error publishing message, ack: " + ack);
        return callback();
      });
    });
  };

  /**
   * Subscribe to messages on a topic
   * @param  {String}   exchangeName  The name of the exchange
   * @param  {String}   qName         The queue name
   * @param  {String}   filter        The filter pattern
   * @param  {Function}   subscribeFunc The function that gets called each time a message happens
   * @param  {Object}   opts          Queue options
   * @param  {Function} callback      Callback function
   */
  this.subscribeToTopic = function(exchangeName, qName, filter, subscribeFunc, opts, callback) {
    if (!callback) {
      if(_.isFunction(opts)){
        callback = opts;
        opts = undefined;
      } else {
        callback = function(){};
      }
    }
    
    opts = opts || {
      autoDelete: false,
      durable: true
    };

    this.getConnection(function(err, connection){
      if(err) {
        //no connection is available, cache the subscribeFunc
        _pendingSubscribers.push({
          exchange: exchangeName,
          queue: qName,
          filter: filter,
          subscriber: subscribeFunc,
          opts: opts,
          callback: callback
        });
        return callback(err);
      }
      self.getExchange(exchangeName, function(err, exchange){
        if(err) return callback(err);
        connection.queue(qName, opts, function(q) {
          q.bind(exchange, filter);
          q.subscribe(subscribeFunc);
          callback();
        });
      });
    });
    
  };

  /**
   * cleanly disconnect from the Cluster
   */
  this.disconnect = function(){
    if(_connection){
      _connection.disconnect();
    }
  };

  /** Private functions */

  /**
   * Setup the connection
   * @param  {Object} connectCfg AMQP connection configurations. 
   * @param  {Object} options    AMQP connection options. 
   * See https://github.com/postwait/node-amqp#connection-options-and-url for the format of the connectCfg and options
   */
  function setupConn(connectCfg, options) {
    var conn = amqp.createConnection(connectCfg, options);
    conn.on('ready', function(){
      debug('received ready event from node-amqp');
      var eventName = 'connection';
      //Ready event will be emitted when re-connected. 
      //To keep backward compatible, only emit 'connection' event for the first time
      if(_connection){
        eventName = 'reconnect';
      }
      _connection = conn;
      _connection._isClosed = false;
      self.emit('ready');
      // wrapped in 'nextTick' for unit test friendliness
      process.nextTick(function(){
        debug('going to emit ' + eventName);
        self.emit(eventName);
      });

      autoSubscribe();
      publishCachedMessages();
    });
    conn.on('error', function(err){
      self.emit('error', err);
    });
    conn.on('close', function(){
      if(_connection){
        _connection._isClosed = true;
      }
    });
  }

  /**
   * Re-add subscriber functions that are created when there is no connection
   */
  function autoSubscribe(){
    //re-add pending subscribers
    if(_pendingSubscribers.length > 0){
      async.each(_pendingSubscribers, function(sub, callback){
        debug('Add pending subscriber', sub);
        self.subscribeToTopic(sub.exchange, sub.queue, sub.filter, sub.subscriber, sub.opts, function(err){
          if(err){
            debug('Failed to add subscriber, keep it', sub);
          } else {
            //done, remove the item from the pending subscribers
            var idx = _pendingSubscribers.indexOf(sub);
            _pendingSubscribers.splice(idx, 1);
            debug('pending subsriber added, now there are ' + _pendingSubscribers.length + ' left');
          }
          return callback();
        });
      }, function(err){
        debug('pending subscribers are added');
      });
    }
  }

  /**
   * Re-publish messages that received when there is no connection
   */
  function publishCachedMessages(){
    if(_cachedPublishMessages.length > 0){
      async.each(_cachedPublishMessages, function(message, callback){
        debug('republish message', message);
        self.publishTopic(message.exchange, message.topic, message.message, message.options, function(err){
          if(err){
            debug('Failed to republish message', message);
          } else {
            var idx = _cachedPublishMessages.indexOf(message);
            _cachedPublishMessages.splice(idx, 1);
            debug('cached publish message re-published, now there are ' + _cachedPublishMessages.length + ' messages left');
          }
          return callback();
        });
      }, function(err){
        debug('cached publish messages processed');
      });
    }
  }
}

util.inherits(AMQPManager, events.EventEmitter);
exports.AMQPManager = AMQPManager;
exports.EventTypes = require('./fhevents.js');